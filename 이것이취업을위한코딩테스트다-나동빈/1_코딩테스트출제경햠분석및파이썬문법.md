## 요구사항에 따라 적절한 알고리즘 설계하기

- 일반적인 컴퓨터에서 연산 횟수 5억 -> 5 ~ 15초 (python)
- 코딩테스트 문제에서 시간제한은 통상 5초 정도 감안 !

문제에서 가장 먼저 확인해야 할 것은 시간 제한(수행시간 요구사항)입니다.

시간 제한이 1초일 때, 일반적인 기준은 다음과 같습니다.
- N=500, 시간 복잡도 : O(N*3)
- N=2000, 시간 복잡도 : O(N*2)
- N=100,000, 시간 복잡도 : O(NlogN)
- N=10,000,000, 시간 복잡도 : O(N)

## 알고리즘 문제 해결 과정

- 일반적으로 대부분의 문제 출제자들은 `핵심 아이디어`를 캐치한다면, 간결하게 소스코드를 작성할 수 있는 형태로 문제를 출제합니다.

## 실수형 알아보기

오늘날 가장 널리 쓰이는 IEEE754 표준에서는 실수형을 저장하기 위해 4바이트, 8바이트 고정된 메모리를 할당하므로, 컴퓨터 시스템은 실수 정보를 정확하게 표현하는 정확도에 한계가 있다.

예를 들어, 10진수에서는 0.3 + 0.6 = 0.9로 정확히 떨어지지만 2진수 쳬게에서는 0.9를 정확하게 표현할 방법이 없다 (최대한 가깝게 표현하려고 함 == 오차가 있다.)

## 리스트 컴프리헨션
0부터 19까지의 수 중에서 홀수만 포함하는 리스트

```python
array = [i for i in range(20) if i%2==1]
```

## 튜플을 사용하면 좋은 경우

- 서로 다른 성질의 데이터를 묶어서 관리해야 할 때
    - 최단 경로 알고리즘에서는 (비용, 노드 번호)의 형태로 튜플 자료형을 자주 사용합니다.
- 데이터의 나열을 해싱(hashing)의 키 값으로 사용해야할 때
    - 튜플은 변경이 불가능 하므로 리스트와 다르게 키 값으로 사용될 수 있습니다.
- 리스트보다 메모리를 효율적으로 사용해야할 때

## Counter 라이브러리

```python
from collections import Counter

counter = Counter(['red', 'blue', 'red', 'green', 'blue', 'blue'])
print(counter['blue']) # 3
print(counter['green']) # 1
print(dict(counter)) # {'red' : 2, 'green' : 1, 'blue' : 3}
```


## 최대 공약수와 최소 공배수
```python
import math

# 최소 공배수(LCM)을 구하는 함수
def lcm(a, b):
    return a*b // math.gcd(a,b)

a = 21
b = 14

print(math.gcd(a,b)) # 7
print(lcm(a,b)) # 42
```

