'''
위상 정렬(Topology Sort)는 '순서가 정해져있는 작업' 을 차례로 수행해야 할 때 그 순서를 결정해주기 위해 사용하는 알고리즘입니다.
순서가 정해져있는 작업의 대표적인 예시는 다음과 같습니다.
          
        / 4학년 되기 -> 정보처리기사 취득 -> 자격 서류 제출
대학생 되기                           v-----/      
        \ 학과 사이트 가입 -> 졸업 시험 신청 -> 졸업하기

그래프의 흐름은 사실 '조건'으로 해석할 수 있습니다.
이러한 그래프를 '조건'에 부합하는 일직선의 순서를 찾아봅시다.

- 위상 정렬 - 
* 대학생 되기 -> 학과 사이트 가입 -> 4학년 되기 
-> 정보처리기사 취득 -> 자격 서류 제출 -> 졸업 시험 신청 -> 졸업하기

또한, 위상 정렬은 여러 개의 답이 존재할 수 있다는 점에서 매력적입니다.
위상 정렬의 조건은 '시작점이 존재'해야 하므로 사이클이 발생하는 그래프에서는 수행할 수 없습니다.
즉, DAG(Directed Acyclic Graph)에만 적용이 가능합니다.

위상 정렬을 수행하는 2가지 해결책을 낸다는 특징이 있습니다.
1. 현재 그래프는 위상 정렬이 가능한지
2. 위상 정렬이 가능하다면 그 결과는 무엇인지

구현 방법은 스택, 큐 모두 가능하지만 이번 시간은 큐로 구현할 예정입니다.

1. 진입차수가 0인 정점을 큐에 삽입합니다.
2. 큐에서 원소를 꺼내 연결된 모든 간선을 제거
3. 간선 제거 이후에 진입차수가 0이 된 정점을 큐에 삽입
4. 큐가 빌 때까지 2번~3번 반복합니다.
    모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재하는 것, 모든 원소를 방문 했다면 큐에서 꺼낸 순서가 위상 정렬의 결과입니다.

# 위상 정렬의 시간 복잡도는 O(V+E)로 매우 빠른 알고리즘 입니다.
'''

def topology_sort():
  result = [0] * (n+1)
  q = []

  # 진입 차수가 0인 노드를 큐에 삽입합니다.
  for i in range(1, n+1):
    if(inDegree[i]==0): q.append(i)
  
  # 위상 정렬이 완전히 수행되려면 정확히 N개의 노드를 방문해야합니다.
  for i in range(1, n+1):
    # n개를 방문하기 전에 큐가 빈다면 사이클이 발생한 것 !
    if len(q)==0:
      print('사이클이 발생했습니다.')
      return

    # x의 간선을 제거한 뒤 진입 차수 갱신
    x = q.pop(0)
    result[i] = x
    for j in range(len(graph[x])):
      y = graph[x][j]

      # 새롭게 진입차수가 0이 된 정점을 큐에 삽입
      inDegree[y] -= 1
      if inDegree[y]==0:
        q.append(y)
  
  for i in range(1, n+1):
    print(result[i], end=' ')
  print()

n = 7 # 노드의 개수

inDegree = [0] * (n+1) # 각 노드의 진입 차수 (다른 노드에서 들어오는 간선)
graph = [[] for _ in range(n+1)] # 인접 리스트를 위한 2차원 배열

graph[1].append(2)
inDegree[2] += 1
graph[1].append(5)
inDegree[5] += 1
graph[2].append(3)
inDegree[3] += 1
graph[3].append(4)
inDegree[4] += 1
graph[4].append(6)
inDegree[6] += 1
graph[5].append(6)
inDegree[6] += 1
graph[6].append(7)
inDegree[7] += 1

topology_sort()